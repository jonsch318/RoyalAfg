// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	money "github.com/Rhymond/go-money"
	models "github.com/jonsch318/royalafg/services/poker/models"
	mock "github.com/stretchr/testify/mock"

	showdown "github.com/jonsch318/royalafg/services/poker/showdown"
)

// Interface is an autogenerated mock type for the Interface type
type Interface struct {
	mock.Mock
}

// AddPlayer provides a mock function with given fields: player
func (_m *Interface) AddPlayer(player *models.Player) {
	_m.Called(player)
}

// ConcludeRound provides a mock function with given fields: winners, publicPlayers
func (_m *Interface) ConcludeRound(winners []showdown.WinnerInfo, publicPlayers []models.PublicPlayer) []*money.Money {
	ret := _m.Called(winners, publicPlayers)

	var r0 []*money.Money
	if rf, ok := ret.Get(0).(func([]showdown.WinnerInfo, []models.PublicPlayer) []*money.Money); ok {
		r0 = rf(winners, publicPlayers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*money.Money)
		}
	}

	return r0
}

// GetMaxBet provides a mock function with given fields:
func (_m *Interface) GetMaxBet() *money.Money {
	ret := _m.Called()

	var r0 *money.Money
	if rf, ok := ret.Get(0).(func() *money.Money); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*money.Money)
		}
	}

	return r0
}

// GetPlayerBet provides a mock function with given fields: id
func (_m *Interface) GetPlayerBet(id string) *money.Money {
	ret := _m.Called(id)

	var r0 *money.Money
	if rf, ok := ret.Get(0).(func(string) *money.Money); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*money.Money)
		}
	}

	return r0
}

// GetPlayerWallet provides a mock function with given fields: id
func (_m *Interface) GetPlayerWallet(id string) *money.Money {
	ret := _m.Called(id)

	var r0 *money.Money
	if rf, ok := ret.Get(0).(func(string) *money.Money); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*money.Money)
		}
	}

	return r0
}

// GetPot provides a mock function with given fields:
func (_m *Interface) GetPot() *money.Money {
	ret := _m.Called()

	var r0 *money.Money
	if rf, ok := ret.Get(0).(func() *money.Money); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*money.Money)
		}
	}

	return r0
}

// HasZeroWallet provides a mock function with given fields: id
func (_m *Interface) HasZeroWallet(id string) bool {
	ret := _m.Called(id)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsAllIn provides a mock function with given fields: id
func (_m *Interface) IsAllIn(id string) bool {
	ret := _m.Called(id)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MustAllIn provides a mock function with given fields: id
func (_m *Interface) MustAllIn(id string) (bool, error) {
	ret := _m.Called(id)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformAllIn provides a mock function with given fields: id
func (_m *Interface) PerformAllIn(id string) (bool, error) {
	ret := _m.Called(id)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformBet provides a mock function with given fields: id
func (_m *Interface) PerformBet(id string) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PerformBlind provides a mock function with given fields: id, amount
func (_m *Interface) PerformBlind(id string, amount *money.Money) error {
	ret := _m.Called(id, amount)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *money.Money) error); ok {
		r0 = rf(id, amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PerformRaise provides a mock function with given fields: id, amount
func (_m *Interface) PerformRaise(id string, amount *money.Money) (int, error) {
	ret := _m.Called(id, amount)

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *money.Money) (int, error)); ok {
		return rf(id, amount)
	}
	if rf, ok := ret.Get(0).(func(string, *money.Money) int); ok {
		r0 = rf(id, amount)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, *money.Money) error); ok {
		r1 = rf(id, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterLobby provides a mock function with given fields: _a0
func (_m *Interface) RegisterLobby(_a0 string) {
	_m.Called(_a0)
}

// RemovePlayer provides a mock function with given fields: id
func (_m *Interface) RemovePlayer(id string) error {
	ret := _m.Called(id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePublicPlayerBuyIn provides a mock function with given fields: p
func (_m *Interface) UpdatePublicPlayerBuyIn(p []models.PublicPlayer) {
	_m.Called(p)
}

// NewInterface creates a new instance of Interface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *Interface {
	mock := &Interface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
